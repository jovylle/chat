<!DOCTYPE html>
<html id="thehtml">

<head>
  <title>QuickGPT - AI Chat Assistant</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="QuickGPT - Fast, modern AI chat interface with markdown support and beautiful dark theme">
  <meta name="keywords" content="AI, ChatGPT, chat, assistant, GPT-3.5, markdown">
  <meta name="author" content="jovylle">
  <meta name="theme-color" content="#0f0f0f" id="meta-theme-color">
  <link rel="manifest" href="manifest.webmanifest">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <link rel="icon" href="quickgpt-icon.png" sizes="512x512" type="image/png">
  <link rel="apple-touch-icon" href="quickgpt-icon.png">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  
  <!-- Performance optimizations -->
  <link rel="preconnect" href="https://cdn.jsdelivr.net">
  <link rel="dns-prefetch" href="https://cdn.jsdelivr.net">
  <link rel="preload" href="prism.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
  <noscript><link rel="stylesheet" href="prism.css"></noscript>
  
  <!-- Lazy load marked.js - will be loaded when first message is sent -->
  <script>
    // Lazy load marked.js when needed
    let markedLoaded = false;
    function loadMarked() {
      if (markedLoaded) return Promise.resolve();
      return new Promise((resolve) => {
        const script = document.createElement('script');
        script.src = 'https://cdn.jsdelivr.net/npm/marked/marked.min.js';
        script.onload = () => {
          markedLoaded = true;
          marked.setOptions({
            breaks: true,
            gfm: true,
            sanitize: false
          });
          resolve();
        };
        document.head.appendChild(script);
      });
    }
  </script>
  <style>
    :root {
      --bg-primary: #0e111a;
      --bg-secondary: #131828;
      --bg-tertiary: #1f2433;
      --bg-message-user: rgba(248, 250, 252, 0.12);
      --bg-message-ai: transparent;
      --text-primary: #f8fafc;
      --text-secondary: #cbd5f5;
      --text-muted: #94a3b8;
      --border-color: rgba(148, 163, 184, 0.6);
      --border-style: dashed;
      --accent-color: #94a3b8;
      --accent-hover: #e0e7ff;
      --success-color: #22c55e;
      --error-color: #ef4444;
      --shadow-light: 0 6px 20px rgba(15, 23, 42, 0.35);
      --shadow-medium: 0 10px 28px rgba(15, 23, 42, 0.45);
      --shadow-heavy: 0 16px 35px rgba(15, 23, 42, 0.55);
      
      /* Typography scale - consistent font sizes */
      --font-xs: 0.75rem;    /* 12px */
      --font-sm: 0.875rem;   /* 14px */
      --font-base: 1rem;     /* 16px - browser default for reading */
      --font-md: 1.125rem;   /* 18px */
      --font-lg: 1.25rem;    /* 20px */
      --font-xl: 1.5rem;     /* 24px */
      
      /* Icon sizes */
      --icon-sm: 18px;
      --icon-base: 20px;
      --icon-lg: 24px;
      --keyboard-offset: 0px;
      --input-offset: 96px;
    }

    html[data-theme="light"] {
      --bg-primary: #f7f7fb;
      --bg-secondary: #ffffff;
      --bg-tertiary: #eef1f6;
      --bg-message-ai: transparent;
      --bg-message-user: #2563eb;
      --text-primary: #111827;
      --text-secondary: #374151;
      --text-muted: #6b7280;
      --border-color: #cbd5e1;
      --shadow-light: 0 1px 3px rgba(0, 0, 0, 0.08);
      --shadow-medium: 0 4px 12px rgba(0, 0, 0, 0.1);
      --shadow-heavy: 0 8px 25px rgba(0, 0, 0, 0.12);
      --accent-color: #2563eb;
      --accent-hover: #1d4ed8;
    }

    html[data-theme="light"] body {
      background: var(--bg-primary);
    }

    * {
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
      margin: 0;
      padding: 0;
      min-height: 100vh;
      background: var(--bg-primary);
      color: var(--text-primary);
      overflow-x: hidden;
      font-size: var(--font-base); /* 16px - browser default */
      line-height: 1.6;
    }

    .app-container {
      display: flex;
      min-height: 100vh;
    }

    .sidebar {
      width: 280px;
      background: var(--bg-primary);
      border-right: 1px var(--border-style) var(--border-color);
      display: flex;
      flex-direction: column;
      transition: transform 0.3s ease;
      z-index: 1000;
      overflow: hidden;
      position: fixed;
      left: 0;
      top: 0;
      height: 100vh;
      box-shadow: 2px 0 10px rgba(0,0,0,0.3);
    }

    /* Slide completely off-screen when collapsed */
    .sidebar.collapsed {
      transform: translateX(-100%);
    }
    
    /* Sidebar backdrop overlay */
    .sidebar-backdrop {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      z-index: 999;
      backdrop-filter: blur(2px);
      transition: opacity 0.3s ease;
    }
    
    .sidebar-backdrop.active {
      display: block;
    }

    .sidebar-header {
      padding: 16px;
      border-bottom: 1px solid var(--border-color);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .sidebar-title {
      font-weight: 600;
      font-size: var(--font-sm);
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .sidebar-toggle {
      background: none;
      border: none;
      color: var(--text-secondary);
      cursor: pointer;
      font-size: var(--icon-base);
      padding: 8px;
      border-radius: 6px;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .sidebar-toggle:hover {
      background: var(--bg-tertiary);
      color: var(--text-primary);
    }

    .conversation-list {
      flex: 1;
      overflow-y: auto;
      overflow-x: hidden;
      padding: 8px;
      max-height: calc(100vh - 200px); /* Ensure scrollable if many conversations */
    }
    
    /* Scrollbar styling for conversation list */
    .conversation-list::-webkit-scrollbar {
      width: 6px;
    }
    
    .conversation-list::-webkit-scrollbar-track {
      background: var(--bg-primary);
    }
    
    .conversation-list::-webkit-scrollbar-thumb {
      background: var(--border-color);
      border-radius: 3px;
    }
    
    .conversation-list::-webkit-scrollbar-thumb:hover {
      background: var(--text-muted);
    }

    .conversation-item {
      padding: 12px;
      margin-bottom: 6px;
      background: var(--bg-secondary);
      border: 1px var(--border-style) var(--border-color);
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    html[data-theme="light"] .conversation-item {
      background: #ffffff;
      border-color: #cbd5e1;
    }

    .conversation-item:hover {
      background: var(--bg-tertiary);
      border-color: var(--border-color);
    }

    .conversation-item.active {
      background: var(--bg-message-user);
      border-color: var(--bg-message-user);
    }

    html[data-theme="light"] .conversation-item.active {
      background: #1d4ed8;
      border-color: #1d4ed8;
    }

    .conversation-title {
      font-size: var(--font-sm);
      font-weight: 500;
      color: var(--text-primary);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .conversation-item.active .conversation-title {
      color: white;
    }

    .conversation-meta {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: var(--font-xs);
      color: var(--text-muted);
      gap: 8px;
    }

    .conversation-item.active .conversation-meta {
      color: rgba(255, 255, 255, 0.8);
    }

    .conversation-tokens {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .conversation-date {
      font-size: var(--font-xs);
      flex: 1;
    }

    .conversation-delete {
      background: none;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: var(--icon-sm);
      transition: all 0.2s;
      opacity: 0;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .conversation-item:hover .conversation-delete {
      opacity: 1;
    }

    .conversation-delete:hover {
      background: rgba(239, 68, 68, 0.2);
      color: #ef4444;
    }

    .new-conversation-btn {
      margin: 8px;
      padding: 12px 16px;
      background: var(--bg-message-user);
      color: white;
      border: none;
      border-radius: 8px;
      font-size: var(--font-sm);
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }

    .new-conversation-btn:hover {
      background: #2563eb;
      transform: translateY(-1px);
      box-shadow: var(--shadow-light);
    }

    .chat-container {
      flex: 1;
      min-height: 100vh;
      background: var(--bg-secondary);
      width: 100%;
      height: 100vh;
      display: flex;
      flex-direction: column;
      position: relative;
      overflow: hidden; /* Prevent container scroll, only messages scroll */
    }

    .chat-header {
      background: rgba(14, 17, 26, 0.75);
      color: var(--text-primary);
      padding: 12px 16px;
      text-align: center;
      font-size: var(--font-xl);
      font-weight: 600;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 20px;
      position: sticky;
      top: 0;
      z-index: 60;
      border-bottom: 1px var(--border-style) var(--border-color);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      min-height: 56px;
    }
    
    /* Light mode transparent header */
    html[data-theme="light"] .chat-header {
      background: rgba(255, 255, 255, 0.85);
      border-bottom: 1px solid rgba(212, 212, 212, 0.3);
    }
    
    .header-model-selector {
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      color: var(--text-primary);
      padding: 8px 14px;
      border-radius: 8px;
      font-size: var(--font-sm);
      cursor: pointer;
      transition: all 0.2s;
      margin-left: 12px;
    }

    /* Hide header model selector to reduce distraction */
    .header-model-selector {
      display: none;
    }
    
    .header-model-selector:hover {
      background: var(--bg-secondary);
      border-color: var(--text-secondary);
    }

    .header-left {
      display: flex;
      align-items: center;
      gap: 15px;
    }
    
    /* Show sidebar toggle on all screen sizes */
    #sidebar-toggle-mobile {
      display: block;
    }

    .header-actions {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .export-chat-btn {
      background: var(--bg-tertiary);
      color: var(--text-secondary);
      border: 1px var(--border-style) var(--border-color);
      border-radius: 8px;
      padding: 10px 14px;
      font-size: var(--icon-base);
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .export-chat-btn:hover {
      background: var(--accent-color);
      color: white;
      transform: translateY(-1px);
      box-shadow: var(--shadow-light);
    }

    .clear-chat-btn {
      background: var(--accent-color);
      color: var(--bg-primary);
      border: none;
      border-radius: 8px;
      padding: 10px 16px;
      font-size: var(--font-sm);
      font-weight: 500;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .clear-chat-btn:hover {
      transform: translateY(-1px);
      box-shadow: var(--shadow-medium);
    }

    .chat-wrapper {
      display: flex;
      flex: 1;
      padding: 20px;
      padding-bottom: calc(var(--input-offset, 96px) + 20px);
      overflow-y: auto;
      overflow-x: hidden;
      background: var(--bg-secondary);
      font-size: var(--font-base); /* Reading text - matches browser default */
      line-height: 1.6;
      justify-content: center;
      min-height: 0; /* Allow flex child to shrink */
    }
    
    /* Scrollbar styling for chat messages */
    .chat-wrapper::-webkit-scrollbar {
      width: 8px;
    }
    
    .chat-wrapper::-webkit-scrollbar-track {
      background: var(--bg-secondary);
    }
    
    .chat-wrapper::-webkit-scrollbar-thumb {
      background: var(--border-color);
      border-radius: 4px;
    }
    
    .chat-wrapper::-webkit-scrollbar-thumb:hover {
      background: var(--text-secondary);
    }

    .chat-messages {
      flex-grow: 1;
      max-width: 800px;
      width: 100%;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .message {
      padding: 0;
      border-radius: 16px;
      max-width: 85%;
      word-wrap: break-word;
      animation: messageSlideIn 0.3s ease-out;
      position: relative;
      border: 1px var(--border-style) var(--border-color);
    }

    @keyframes messageSlideIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .user-message {
      background: var(--bg-message-user);
      color: white;
      align-self: flex-end;
      text-align: right;
      box-shadow: var(--shadow-light);
      border: 1px var(--border-style) rgba(255, 255, 255, 0.6);
      padding: 14px 18px;
      border-radius: 16px;
    }

    html[data-theme="light"] .user-message {
      background: #2563eb;
      border-color: #1d4ed8;
      color: #f8fafc;
    }

    .user-message-inner {
      display: flex;
      align-items: flex-start;
      justify-content: flex-end;
      gap: 8px;
    }

    .user-message-text { flex: 1; word-break: break-word; }

    .message-delete {
      background: rgba(255,255,255,0.2);
      border: none;
      color: white;
      border-radius: 6px;
      padding: 6px 10px;
      font-size: var(--font-xs);
      cursor: pointer;
      opacity: 0.7;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .message-delete:hover { opacity: 1; background: rgba(255,255,255,0.3); }
    .ai-message .message-delete { background: var(--bg-tertiary); color: var(--text-secondary); }
    .ai-message .message-delete:hover { background: var(--error-color); color: white; }

    .scroll-to-bottom-btn {
      position: fixed;
      bottom: calc(110px + env(safe-area-inset-bottom, 0)); /* Above fixed input area */
      left: 50%;
      transform: translateX(-50%);
      margin: 0;
      background: var(--accent-color);
      color: white;
      border: none;
      border-radius: 24px;
      padding: 12px 20px;
      font-size: var(--font-sm);
      font-weight: 500;
      cursor: pointer;
      box-shadow: var(--shadow-medium);
      z-index: 100;
      opacity: 0.95;
      transition: all 0.2s;
      display: none;
    }

    .scroll-to-bottom-btn:hover { opacity: 1; }
    .scroll-to-bottom-btn.visible { display: block; animation: messageSlideIn 0.2s ease-out; }

    .export-dropdown {
      position: relative;
    }

    .export-menu {
      position: absolute;
      top: 100%;
      right: 0;
      margin-top: 4px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      box-shadow: var(--shadow-medium);
      z-index: 200;
      min-width: 140px;
      padding: 4px;
      display: none;
    }

    .export-menu.visible { display: block; }
    .export-menu button {
      display: block;
      width: 100%;
      padding: 10px 14px;
      text-align: left;
      background: none;
      border: none;
      color: var(--text-primary);
      cursor: pointer;
      border-radius: 6px;
      font-size: var(--font-sm);
    }
    .export-menu button:hover { background: var(--accent-color); color: white; }

    .toast-with-action { display: flex; align-items: center; gap: 12px; flex-wrap: wrap; }
    .toast-with-action .toast-retry,
    .toast-with-action .toast-action {
      background: rgba(255,255,255,0.3);
      border: none;
      color: white;
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 600;
    }
    .toast-with-action .toast-retry:hover,
    .toast-with-action .toast-action:hover {
      background: rgba(255,255,255,0.5);
    }

    .ai-message {
      background: none;
      color: var(--text-primary);
      text-align: left;
      border: none !important;
      box-shadow: none;
      border-radius: 0;
      padding: 0;
      margin: 0;
    }

    .ai-message-content {
      border: none;
      border-radius: 0;
      background: transparent;
      box-shadow: none;
      padding: 0;
    }

    .ai-message-footer {
      margin-top: 12px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      font-size: var(--font-xs);
      color: var(--text-secondary);
      gap: 12px;
      padding-top: 8px;
    }

    .ai-message-time {
      display: flex;
      align-items: center;
      gap: 6px;
      white-space: nowrap;
    }

    .ai-message-actions {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .icon-btn {
      border: none;
      background: rgba(255, 255, 255, 0.06);
      color: var(--text-secondary);
      width: 36px;
      height: 36px;
      border-radius: 50%;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease;
    }

    .icon-btn svg {
      width: 18px;
      height: 18px;
      fill: currentColor;
    }

    .icon-btn:hover {
      background: var(--accent-color);
      color: white;
    }

    .code-copy-btn {
      position: absolute;
      top: 8px;
      right: 8px;
      width: 32px;
      height: 32px;
      border: 1px var(--border-style) var(--border-color);
      border-radius: 50%;
      background: rgba(15, 23, 42, 0.9);
      color: var(--text-secondary);
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
      z-index: 5;
    }

    .code-copy-btn:hover {
      background: var(--accent-color);
      color: var(--bg-primary);
    }

    .ai-label {
      font-size: var(--font-xs);
      color: var(--text-secondary);
      font-weight: 500;
    }

    .stop-btn {
      padding: 14px 24px;
      background: var(--error-color);
      color: white;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      font-size: var(--font-base);
      font-weight: 500;
      min-width: 80px;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .stop-btn:hover {
      filter: brightness(1.1);
    }

    .theme-toggle {
      background: var(--bg-tertiary);
      color: var(--text-secondary);
      border: 1px var(--border-style) var(--border-color);
      border-radius: 8px;
      padding: 10px 14px;
      font-size: var(--icon-base);
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .theme-toggle:hover {
      background: var(--accent-color);
      color: white;
    }

    .input-container {
      display: flex;
      align-items: flex-start;
      padding: 16px 20px;
      padding-bottom: calc(16px + var(--keyboard-offset, 0px));
      background: var(--bg-primary);
      border-top: 1px var(--border-style) var(--border-color);
      justify-content: center;
      gap: 12px;
      position: sticky;
      bottom: var(--keyboard-offset, 0px);
      z-index: 50;
    }
    
    /* Light mode transparent input */
    html[data-theme="light"] .input-container {
      background: rgba(255, 255, 255, 0.95);
      border-top: 1px solid rgba(212, 212, 212, 0.5);
    }

    .input-container.sending input,
    .input-container.sending textarea {
      pointer-events: none;
      opacity: 0.7;
    }

    body.chat-loading .suggested-prompt {
      pointer-events: none;
      opacity: 0.6;
    }

    .input-wrapper {
      position: relative;
      flex-grow: 1;
      max-width: 600px;
      min-height: 72px;
    }

    #user-input {
      flex-grow: 1;
      width: 100%;
      min-height: 52px;
      max-height: 200px;
      padding: 14px 18px;
      border: 2px var(--border-style) var(--border-color);
      border-radius: 12px;
      font-size: var(--font-base); /* Matches browser default for input */
      line-height: 1.5;
      font-family: inherit;
      max-width: 600px;
      background: rgba(15, 23, 42, 0.7);
      color: var(--text-primary);
      transition: all 0.3s ease;
      resize: vertical;
    }

    html[data-theme="light"] #user-input {
      background: #eef2f7;
      border-color: #cbd5e1;
      color: #111827;
    }

    #user-input:focus {
      outline: none;
      border-color: var(--accent-color);
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
    }

    #user-input::placeholder {
      color: var(--text-muted);
    }
    
    /* Hide scrollbar on textarea */
    #user-input::-webkit-scrollbar {
      display: none;
    }
    
    #user-input {
      -ms-overflow-style: none;  /* IE and Edge */
      scrollbar-width: none;  /* Firefox */
    }

    .char-counter {
      position: absolute;
      bottom: -20px;
      right: 0;
      font-size: var(--font-xs);
      color: var(--text-muted);
      opacity: 0.7;
    }

    .char-counter.warning {
      color: #f59e0b;
    }

    .char-counter.danger {
      color: #ef4444;
    }

    #send-button {
      padding: 12px 18px;
      background: var(--accent-color);
      color: var(--bg-primary);
      border: 1px var(--border-style) var(--border-color);
      border-radius: 12px;
      cursor: pointer;
      font-size: var(--font-base);
      font-weight: 600;
      transition: all 0.2s ease;
      min-width: 96px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      height: 52px;
      box-sizing: border-box;
    }

    #send-button:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: var(--shadow-light);
    }

    #send-button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }

    #send-button .btn-spinner {
      display: inline-block;
      width: 18px;
      height: 18px;
      border: 2px solid rgba(255,255,255,0.4);
      border-top-color: #fff;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
      vertical-align: middle;
    }

    .suggested-prompts {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
      margin-top: 16px;
      padding: 0 20px;
    }

    .suggested-prompt {
      background: var(--bg-tertiary);
      color: var(--text-secondary);
      border: 1px var(--border-style) var(--border-color);
      border-radius: 20px;
      padding: 10px 18px;
      font-size: var(--font-sm);
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .suggested-prompt:hover {
      background: var(--accent-color);
      color: white;
      border-color: var(--accent-color);
      transform: translateY(-2px);
      box-shadow: var(--shadow-light);
    }

    .placeholder-message {
      color: var(--text-muted);
      margin: auto;
      text-align: center;
      font-size: var(--font-md);
      opacity: 0.8;
    }

    .loading-yet {
      padding: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
    }

    .typing-dot {
      width: 8px;
      height: 8px;
      background: var(--accent-color);
      border-radius: 50%;
      animation: typingBounce 1.4s ease-in-out infinite;
    }

    .typing-dot:nth-child(2) { animation-delay: 0.2s; }
    .typing-dot:nth-child(3) { animation-delay: 0.4s; }

    @keyframes typingBounce {
      0%, 60%, 100% { transform: translateY(0); }
      30% { transform: translateY(-6px); }
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .info-button {
      background: var(--bg-tertiary);
      color: var(--text-secondary);
      border: 1px solid var(--border-color);
      border-radius: 50%;
      cursor: pointer;
      font-size: var(--font-sm);
      height: 28px;
      width: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
    }

    .info-button:hover {
      background: var(--accent-color);
      color: white;
      transform: scale(1.1);
    }

    .info-panel {
      position: absolute;
      top: 60px;
      right: 20px;
      background: var(--bg-tertiary);
      color: var(--text-primary);
      padding: 16px;
      border: 1px solid var(--border-color);
      border-radius: 12px;
      box-shadow: var(--shadow-medium);
      z-index: 1000;
      min-width: 250px;
      display: none;
    }

    .info-panel a {
      color: var(--accent-color);
      text-decoration: none;
    }

    .info-panel a:hover {
      text-decoration: underline;
    }

    .info-button:hover + .info-panel,
    .info-panel:hover {
      display: block;
    }

    /* Markdown styling */
    .ai-message h1, .ai-message h2, .ai-message h3, .ai-message h4, .ai-message h5, .ai-message h6 {
      color: var(--text-primary);
      margin: 16px 0 8px 0;
    }

    /* AI message content typography - proper hierarchy */
    .ai-message h1 { font-size: var(--font-xl); margin: 1em 0 0.5em; line-height: 1.3; }
    .ai-message h2 { font-size: var(--font-lg); margin: 1em 0 0.5em; line-height: 1.3; }
    .ai-message h3 { font-size: var(--font-md); margin: 1em 0 0.5em; line-height: 1.3; }
    .ai-message p { margin: 0.75em 0; line-height: 1.6; }
    .ai-message ul, .ai-message ol { margin: 0.75em 0; padding-left: 1.5em; line-height: 1.6; }
    .ai-message li { margin: 0.25em 0; }

    .ai-message p {
      margin: 8px 0;
      line-height: 1.6;
    }

    .ai-message ul, .ai-message ol {
      margin: 8px 0;
      padding-left: 24px;
    }

    .ai-message li {
      margin: 4px 0;
    }

    .ai-message code {
      background: var(--bg-primary);
      color: #f8f8f2;
      padding: 2px 6px;
      border-radius: 4px;
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
      font-size: var(--font-sm);
    }

    .ai-message pre {
      background: #0f172a;
      color: #e2e8f0;
      padding: 14px;
      border-radius: 8px;
      overflow-x: auto;
      margin: 12px 0;
      border: 1px var(--border-style) var(--border-color);
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      font-size: var(--font-sm);
      line-height: 1.6;
      position: relative;
    }

    html[data-theme="light"] .ai-message pre {
      background: #0f172a;
      color: #e2e8f0;
      border-color: #1f2937;
    }
    
    html[data-theme="light"] .ai-message pre code {
      color: #e2e8f0;
    }

    .ai-message pre code {
      background: none;
      padding: 0;
      color: inherit;
    }
    
    /* Better code token colors - Dark mode */
    .ai-message pre code .token.comment { color: #94a3b8; }
    .ai-message pre code .token.keyword { color: #60a5fa; font-weight: 600; }
    .ai-message pre code .token.string { color: #fbbf24; }
    .ai-message pre code .token.function { color: #a5b4fc; }
    .ai-message pre code .token.number { color: #34d399; }
    .ai-message pre code .token.operator { color: #e2e8f0; }
    .ai-message pre code .token.punctuation { color: #e2e8f0; }
    
    /* Light mode - same palette to ensure contrast */
    html[data-theme="light"] .ai-message pre code .token.comment { color: #94a3b8; }
    html[data-theme="light"] .ai-message pre code .token.keyword { color: #60a5fa; font-weight: 700; }
    html[data-theme="light"] .ai-message pre code .token.string { color: #fbbf24; font-weight: 600; }
    html[data-theme="light"] .ai-message pre code .token.function { color: #a5b4fc; font-weight: 600; }
    html[data-theme="light"] .ai-message pre code .token.number { color: #34d399; font-weight: 600; }
    html[data-theme="light"] .ai-message pre code .token.operator { color: #e2e8f0; }
    html[data-theme="light"] .ai-message pre code .token.punctuation { color: #e2e8f0; }

    .ai-message blockquote {
      border-left: 4px solid var(--accent-color);
      margin: 12px 0;
      padding-left: 16px;
      color: var(--text-secondary);
      font-style: italic;
    }

    .ai-message strong {
      color: var(--text-primary);
      font-weight: 600;
    }

    .ai-message em {
      color: var(--text-secondary);
    }

    /* Toast notification */
    .toast {
      position: fixed;
      bottom: calc(20px + env(safe-area-inset-bottom, 0px));
      left: 50%;
      transform: translateX(-50%);
      color: white;
      padding: 12px 20px;
      border-radius: 8px;
      box-shadow: var(--shadow-medium);
      z-index: 10000;
      animation: toastSlideIn 0.3s ease-out;
    }

    .toast.toast-success,
    .toast { background: var(--success-color); }
    .toast.toast-error { background: var(--error-color); }
    .toast.toast-info { background: var(--accent-color); }

    @keyframes toastSlideIn {
      from {
        opacity: 0;
        transform: translateX(100%);
      }
      to {
        opacity: 1;
        transform: translateX(0);
      }
    }

    @media (prefers-reduced-motion: reduce) {
      .message, .toast, .scroll-to-bottom-btn.visible { animation: none; }
      .typing-dot { animation: none; opacity: 0.8; }
      * { animation-duration: 0.01ms !important; transition-duration: 0.01ms !important; }
    }

    /* Settings Modal */
    .settings-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      z-index: 2000;
      justify-content: center;
      align-items: center;
      animation: fadeIn 0.2s;
    }

    .settings-modal.active {
      display: flex;
    }

    .settings-content {
      background: var(--bg-secondary);
      border-radius: 16px;
      padding: 24px;
      max-width: 600px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: var(--shadow-heavy);
      animation: slideUp 0.3s;
    }

    @keyframes slideUp {
      from { transform: translateY(50px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }

    .settings-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 24px;
      padding-bottom: 16px;
      border-bottom: 1px solid var(--border-color);
    }

    .settings-header h2 {
      margin: 0;
      font-size: var(--font-xl);
      color: var(--text-primary);
    }

    .settings-close {
      background: none;
      border: none;
      font-size: var(--icon-lg);
      color: var(--text-secondary);
      cursor: pointer;
      padding: 8px;
      line-height: 1;
      transition: color 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .settings-close:hover {
      color: var(--text-primary);
    }

    .settings-section {
      margin-bottom: 24px;
    }

    .settings-section h3 {
      font-size: var(--font-base);
      color: var(--text-primary);
      margin: 0 0 12px 0;
      font-weight: 600;
    }

    .settings-section p {
      font-size: var(--font-sm);
      color: var(--text-secondary);
      margin: 0 0 12px 0;
      line-height: 1.5;
    }

    .settings-input, .settings-select {
      width: 100%;
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 12px 14px;
      color: var(--text-primary);
      font-size: var(--font-sm);
      font-family: inherit;
      transition: all 0.2s;
    }

    .settings-input:focus, .settings-select:focus {
      outline: none;
      border-color: var(--accent-color);
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
    }

    .settings-input::placeholder {
      color: var(--text-muted);
    }

    .settings-toggle {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px;
      background: var(--bg-tertiary);
      border-radius: 8px;
      cursor: pointer;
      transition: background 0.2s;
    }

    .settings-toggle:hover {
      background: var(--bg-primary);
    }

    .toggle-switch {
      position: relative;
      width: 48px;
      height: 24px;
      background: var(--bg-primary);
      border-radius: 12px;
      transition: background 0.3s;
    }

    .toggle-switch.active {
      background: var(--accent-color);
    }

    .toggle-switch::after {
      content: '';
      position: absolute;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: white;
      top: 3px;
      left: 3px;
      transition: transform 0.3s;
    }

    .toggle-switch.active::after {
      transform: translateX(24px);
    }

    .settings-button {
      background: var(--accent-color);
      color: white;
      border: none;
      border-radius: 8px;
      padding: 12px 24px;
      font-size: var(--font-sm);
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      width: 100%;
    }

    .settings-button:hover {
      background: var(--accent-hover);
      transform: translateY(-1px);
    }

    .settings-button.secondary {
      background: var(--bg-tertiary);
      color: var(--text-primary);
    }

    .settings-button.secondary:hover {
      background: var(--bg-primary);
    }

    .settings-button-group {
      display: flex;
      gap: 12px;
      margin-top: 16px;
    }

    .settings-button-group .settings-button {
      flex: 1;
    }

    .api-key-hint {
      font-size: var(--font-xs);
      color: var(--text-muted);
      margin-top: 4px;
    }

    .settings-badge {
      display: inline-block;
      background: var(--accent-color);
      color: white;
      font-size: var(--font-xs);
      font-weight: 600;
      padding: 4px 8px;
      border-radius: 12px;
      margin-left: 8px;
    }

    /* Responsive design */
    @media (max-width: 1024px) {
      /* Styles already handled globally */
    }

    @media (max-width: 768px) {
      .sidebar {
        width: 280px;
      }
      
      .chat-header {
        padding: 12px 15px;
        font-size: var(--font-md);
      }
      
      .header-left span {
        font-size: var(--font-base);
      }
      
      .chat-wrapper {
        padding: 12px;
        padding-bottom: calc(var(--input-offset, 96px) + 12px);
      }
      
      .chat-messages {
        max-width: 100%;
        gap: 12px;
      }
      
      .message {
        max-width: 90%;
        padding: 12px 16px;
        font-size: var(--font-base); /* Maintain readability on mobile */
      }

      .clear-chat-btn span {
        display: none;
      }

      .input-container {
        padding: 12px;
        gap: 8px;
        position: fixed;
        left: 0;
        right: 0;
        /* bottom: env(safe-area-inset-bottom, 0px); */
        width: 100%;
        border-radius: 0;
        border-top: 1px var(--border-style) var(--border-color);
        box-shadow: 0 -14px 30px rgba(0, 0, 0, 0.35);
        background: var(--bg-primary);
        backdrop-filter: blur(18px);
        /* padding-bottom: calc(12px + env(safe-area-inset-bottom, 0px)); */
      }
      
      #user-input {
        font-size: var(--font-base); /* Keep at browser default */
        padding: 12px 16px;
        min-height: 44px;
      }

      #send-button {
        padding: 12px 20px;
        font-size: var(--font-sm);
      }
      
      .regenerate-btn, .copy-btn {
        font-size: var(--font-xs);
        padding: 6px 10px;
      }
      
      .ai-message pre {
        font-size: var(--font-sm);
        padding: 12px;
      }
      
      .conversation-item {
        padding: 10px;
      }
      
      .settings-content {
        width: 95%;
        padding: 20px;
      }
      
      .scroll-to-bottom-btn {
        bottom: calc(170px + env(safe-area-inset-bottom, 0)); /* Stay above fixed input */
      }
    }

    @media (max-width: 480px) {
      .header-left span {
        font-size: var(--font-sm);
      }
      
      .header-actions {
        gap: 4px;
      }
      
      .theme-toggle, .export-chat-btn, #settings-btn {
        font-size: var(--icon-sm);
        padding: 6px 8px;
      }
      
      .clear-chat-btn {
        padding: 8px 12px;
        font-size: var(--font-sm);
      }
      
      .message {
        max-width: 95%;
        font-size: var(--font-base); /* Maintain readability */
        padding: 12px 16px;
      }
      
      
      .ai-message-footer {
        flex-direction: column;
        align-items: flex-start;
        gap: 8px;
      }

      .ai-message-actions {
        width: 100%;
        justify-content: flex-start;
      }
      
      .settings-button-group {
        flex-direction: column;
      }
      
      .settings-content {
        padding: 16px;
        max-height: 85vh;
      }
      
      .settings-header h2 {
        font-size: var(--font-lg);
      }
      
      .sidebar {
        width: 260px;
      }
      
      .conversation-item {
        padding: 10px;
      }
      
      .conversation-title {
        font-size: var(--font-xs);
      }
      
      .conversation-meta {
        font-size: 10px;
      }
      
      .scroll-to-bottom-btn {
        bottom: 85px; /* Adjust for even smaller input on tiny screens */
        padding: 10px 16px;
        font-size: var(--font-xs);
      }
      
      #user-input {
        font-size: 16px;
      }
    }
  </style>
</head>

<body>
  <div class="app-container">
    <!-- Sidebar for conversations -->
    <div class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <span class="sidebar-title">Conversations</span>
        <button class="sidebar-toggle" id="sidebar-toggle" aria-label="Toggle sidebar">‚ò∞</button>
      </div>
      <div class="conversation-list" id="conversation-list">
        <!-- Conversations will be rendered here -->
      </div>
      <button class="new-conversation-btn" id="new-conversation-btn">
        <span>+</span>
        <span>New Conversation</span>
      </button>
    </div>
    
    <!-- Backdrop overlay -->
    <div class="sidebar-backdrop" id="sidebar-backdrop"></div>

    <!-- Main chat area -->
    <div class="chat-container">
      <div class="chat-header">
        <div class="header-left">
          <button class="sidebar-toggle" id="sidebar-toggle-mobile" aria-label="Toggle sidebar" style="background: none; border: none; color: var(--text-primary); cursor: pointer; font-size: var(--icon-base); padding: 0 12px 0 0;"><i class="fa-solid fa-bars"></i></button>
          <span>Chatbot</span>
          <select class="header-model-selector" id="header-model-selector" aria-label="Select AI model">
            <optgroup label="OpenAI">
              <option value="gpt-3.5-turbo">GPT-3.5 Turbo</option>
              <option value="gpt-3.5-turbo-16k">GPT-3.5 Turbo 16k</option>
              <option value="gpt-4o-mini">GPT-4o Mini</option>
            </optgroup>
            <optgroup label="Claude">
              <option value="claude-3-haiku-20240307">Claude 3 Haiku</option>
              <option value="claude-3-5-haiku-20241022">Claude 3.5 Haiku</option>
            </optgroup>
          </select>
        </div>
        <div class="header-actions">
          <button class="theme-toggle" id="settings-btn" title="Settings" aria-label="Settings" style="background: none; border: none; color: var(--text-primary); cursor: pointer; font-size: var(--icon-base); padding: 10px 14px; border-radius: 8px; transition: background 0.2s;"><i class="fa-solid fa-gear"></i></button>
          <button class="theme-toggle" id="theme-toggle" title="Toggle light/dark" aria-label="Toggle theme"><i class="fa-solid fa-moon"></i></button>
          <!-- Export dropdown removed from header; use settings modal instead -->
        </div>
      </div>
    <div class="chat-wrapper" id="chat-wrapper">
      <button type="button" class="scroll-to-bottom-btn" id="scroll-to-bottom-btn" aria-label="Scroll to bottom">‚Üì New messages</button>
      <div class="chat-messages" id="chat-box" role="log" aria-live="polite" aria-label="Chat messages">
        <div class="placeholder-message" id="placeholder-wrap">
          <span>Start a conversation by typing a message...</span>
          <div class="suggested-prompts" id="suggested-prompts">
            <button type="button" class="suggested-prompt" data-prompt="Explain quantum computing in simple terms">Explain quantum computing</button>
            <button type="button" class="suggested-prompt" data-prompt="Write a short haiku about coding">Write a haiku</button>
            <button type="button" class="suggested-prompt" data-prompt="Help me debug: my function returns undefined">Debug this code</button>
            <button type="button" class="suggested-prompt" data-prompt="Summarize the key points of a long article">Summarize an article</button>
          </div>
        </div>
      </div>
    </div>
    <div class="input-container">
      <div class="input-wrapper">
        <textarea id="user-input" placeholder="Type your message..." autofocus aria-label="Message input" maxlength="2000" rows="1"></textarea>
        <div class="char-counter" id="char-counter">0 / 2000</div>
      </div>
      <button id="send-button" type="button" aria-label="Send message">Send</button>
      <button id="stop-button" type="button" class="stop-btn" aria-label="Stop generation" style="display: none;">Stop</button>
    </div>
  </div><!-- .chat-container -->
  </div><!-- .app-container -->

  <!-- Settings Modal -->
  <div class="settings-modal" id="settings-modal">
    <div class="settings-content">
      <div class="settings-header">
        <h2>Settings</h2>
        <button class="settings-close" id="settings-close">√ó</button>
      </div>

      <!-- API Key Section -->
      <div class="settings-section">
        <h3>üîë API Configuration</h3>
        <p>Choose your AI model. Free service uses GPT-3.5 (our API key). Add your own key for more models.</p>
        
        <label style="display: block; margin-bottom: 8px; font-size: var(--font-sm); color: var(--text-primary); font-weight: 500;">Model</label>
        <select class="settings-select" id="model-select">
          <optgroup label="OpenAI Models">
            <option value="gpt-3.5-turbo">GPT-3.5 Turbo</option>
            <option value="gpt-3.5-turbo-16k">GPT-3.5 Turbo 16k</option>
            <option value="gpt-4o-mini">GPT-4o Mini</option>
          </optgroup>
          <optgroup label="Claude Models">
            <option value="claude-3-haiku-20240307">Claude 3 Haiku (Fastest)</option>
            <option value="claude-3-5-haiku-20241022">Claude 3.5 Haiku</option>
          </optgroup>
        </select>
        <div class="api-key-hint" style="margin-top: 8px;">Free service: GPT-3.5, GPT-4o Mini, Claude Haiku models</div>
        
        <div style="margin-top: 20px;">
          <label style="display: block; margin-bottom: 8px; font-size: var(--font-sm); color: var(--text-primary); font-weight: 500;">
            Custom Instructions <span style="font-weight: 400; opacity: 0.7; font-size: var(--font-xs);">(Optional)</span>
          </label>
          <textarea 
            id="system-prompt" 
            class="settings-input" 
            placeholder="You are a helpful chat assistant."
            rows="3"
            style="width: 100%; resize: vertical; min-height: 60px; font-family: inherit; padding: 10px; border-radius: 8px; border: 1px solid var(--border-color); background: var(--bg-secondary); color: var(--text-primary);"
          ></textarea>
          <div class="api-key-hint" style="margin-top: 6px;">Add context or instructions for the AI. Leave empty for default.</div>
        </div>
        
        <div style="margin-top: 16px;">
          <div class="settings-toggle" id="custom-api-toggle">
            <span>Use Your Own API Key <span class="settings-badge">Advanced</span></span>
            <div class="toggle-switch" id="custom-api-switch"></div>
          </div>
        </div>

        <div id="custom-api-section" style="display: none; margin-top: 16px;">
          <label style="display: block; margin-bottom: 8px; font-size: var(--font-sm); color: var(--text-primary); font-weight: 500;">Provider</label>
          <select class="settings-select" id="api-provider">
            <option value="openai">OpenAI (GPT-3.5, GPT-4, GPT-4o)</option>
            <option value="anthropic">Anthropic (Claude) - Coming Soon</option>
            <option value="groq">Groq - Coming Soon</option>
          </select>

          <label style="display: block; margin: 16px 0 8px; font-size: var(--font-sm); color: var(--text-primary); font-weight: 500;">API Key</label>
          <input type="password" class="settings-input" id="api-key-input" placeholder="sk-...">
          <div class="api-key-hint">Your API key is stored locally and never sent to our servers.</div>

          <label style="display: block; margin: 16px 0 8px; font-size: var(--font-sm); color: var(--text-primary); font-weight: 500;">Custom Model</label>
          <select class="settings-select" id="custom-model-select">
            <option value="gpt-3.5-turbo">GPT-3.5 Turbo</option>
            <option value="gpt-3.5-turbo-16k">GPT-3.5 Turbo 16k</option>
            <option value="gpt-4o-mini">GPT-4o Mini</option>
            <option value="gpt-4o">GPT-4o</option>
            <option value="gpt-4">GPT-4</option>
            <option value="gpt-4-turbo">GPT-4 Turbo</option>
          </select>
        </div>
      </div>

      <!-- Data Management -->
      <div class="settings-section">
        <h3>üíæ Data Management</h3>
        <div class="settings-button-group">
          <button class="settings-button secondary" id="export-all-btn">Export All Data</button>
          <button class="settings-button secondary" id="import-data-btn">Import Data</button>
        </div>
        <input type="file" id="import-file-input" accept=".json" style="display: none;">
        <div class="settings-button-group" style="margin-top: 12px;">
          <button class="settings-button secondary" style="background: rgba(239, 68, 68, 0.2); color: #ef4444;" id="clear-all-data-btn">Clear All Data</button>
        </div>
      </div>

      <!-- About -->
      <div class="settings-section">
        <h3>‚ÑπÔ∏è About</h3>
        <p>QuickGPT v2.0 - Fast, modern AI chat interface</p>
        <p style="font-size: var(--font-xs);">
          Learn more or contribute on <a href="https://github.com/jovylle/chat" style="color: var(--accent-color);" target="_blank" rel="noopener noreferrer">github.com/jovylle/chat</a>
        </p>
      </div>
    </div>
  </div>

  <script>
    const STORAGE_KEY = 'quickgpt_conversations';
    const THEME_KEY = 'quickgpt_theme';
    const ACTIVE_CONVO_KEY = 'quickgpt_active_conversation';
    const API_CONFIG_KEY = 'quickgpt_api_config';
    const SIDEBAR_STATE_KEY = 'quickgpt_sidebar_collapsed';
    const MAX_CHARS = 2000;
    const APP_VERSION = '1.0.0-dev';
    const APP_PATCH = 'patch-2';
    const isMobileDevice = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent || '');
    
    // Conversation management
    let conversations = {};
    let activeConversationId = null;
    let currentAbortController = null;
    let lastFailedUserMessage = null;

    const userInput = document.getElementById('user-input');
    const chatBox = document.getElementById('chat-box');
    const chatWrapper = document.getElementById('chat-wrapper');
    const sendButton = document.getElementById('send-button');
    const stopButton = document.getElementById('stop-button');
    const clearChatBtn = document.getElementById('clear-chat-btn');
    const exportChatBtn = document.getElementById('export-chat-btn');
    const exportMenu = document.getElementById('export-menu');
    const scrollToBottomBtn = document.getElementById('scroll-to-bottom-btn');
    const themeToggle = document.getElementById('theme-toggle');
    const charCounter = document.getElementById('char-counter');
    const sidebar = document.getElementById('sidebar');
    const sidebarToggle = document.getElementById('sidebar-toggle');
    const sidebarToggleMobile = document.getElementById('sidebar-toggle-mobile');
    const sidebarBackdrop = document.getElementById('sidebar-backdrop');
    const conversationList = document.getElementById('conversation-list');
    const newConversationBtn = document.getElementById('new-conversation-btn');
    const settingsBtn = document.getElementById('settings-btn');
    const settingsModal = document.getElementById('settings-modal');
    const settingsClose = document.getElementById('settings-close');
    const customApiToggle = document.getElementById('custom-api-toggle');
    const customApiSwitch = document.getElementById('custom-api-switch');
    const customApiSection = document.getElementById('custom-api-section');
    const apiProviderSelect = document.getElementById('api-provider');
    const apiKeyInput = document.getElementById('api-key-input');
    const modelSelect = document.getElementById('model-select');
    const headerModelSelect = document.getElementById('header-model-selector');
    const exportAllBtn = document.getElementById('export-all-btn');
    const importDataBtn = document.getElementById('import-data-btn');
    const importFileInput = document.getElementById('import-file-input');
    const clearAllDataBtn = document.getElementById('clear-all-data-btn');
    const importConversationsBtn = document.getElementById('import-conversations-btn');

    let versionToastShown = false;
    let deferredPrompt = null;
    let keyboardOffsetTimer = null;
    let inputOffsetTimer = null;

    function updateKeyboardOffset() {
      if (!window.visualViewport) return;
      const viewport = window.visualViewport;
      const keyboardHeight = Math.max(
        0,
        window.innerHeight - viewport.height - viewport.offsetTop
      );
      document.documentElement.style.setProperty('--keyboard-offset', `${keyboardHeight}px`);
      console.log(`[Keyboard] offset=${Math.round(keyboardHeight)}px`);
    }

    function scheduleKeyboardOffsetUpdate() {
      if (keyboardOffsetTimer) return;
      keyboardOffsetTimer = setTimeout(() => {
        keyboardOffsetTimer = null;
        updateKeyboardOffset();
      }, 100);
    }

    if (window.visualViewport) {
      window.visualViewport.addEventListener('resize', scheduleKeyboardOffsetUpdate);
      window.visualViewport.addEventListener('scroll', scheduleKeyboardOffsetUpdate);
      scheduleKeyboardOffsetUpdate();
    }

    function updateInputOffset() {
      if (!inputContainer) return;
      const height = inputContainer.offsetHeight || 0;
      document.documentElement.style.setProperty('--input-offset', `${height}px`);
    }

    function scheduleInputOffsetUpdate() {
      if (inputOffsetTimer) return;
      inputOffsetTimer = setTimeout(() => {
        inputOffsetTimer = null;
        updateInputOffset();
      }, 60);
    }

    window.addEventListener('resize', scheduleInputOffsetUpdate);
    userInput.addEventListener('input', scheduleInputOffsetUpdate);
    scheduleInputOffsetUpdate();
    // API Configuration
    let apiConfig = {
      useCustomKey: false,
      provider: 'openai',
      apiKey: '',
      model: 'gpt-3.5-turbo',
      systemPrompt: ''
    };

    function loadApiConfig() {
      try {
        const stored = localStorage.getItem(API_CONFIG_KEY);
        if (stored) {
          apiConfig = { ...apiConfig, ...JSON.parse(stored) };
        }
      } catch (e) {
        console.error('Failed to load API config:', e);
      }
    }

    function saveApiConfig() {
      try {
        localStorage.setItem(API_CONFIG_KEY, JSON.stringify(apiConfig));
      } catch (e) {
        console.error('Failed to save API config:', e);
      }
    }

    const customModelSelect = document.getElementById('custom-model-select');
    const systemPromptTextarea = document.getElementById('system-prompt');

    function updateApiUI() {
      customApiSwitch.classList.toggle('active', apiConfig.useCustomKey);
      customApiSection.style.display = apiConfig.useCustomKey ? 'block' : 'none';
      apiProviderSelect.value = apiConfig.provider;
      apiKeyInput.value = apiConfig.apiKey;
      modelSelect.value = apiConfig.model;
      if (customModelSelect) customModelSelect.value = apiConfig.model;
      if (systemPromptTextarea) systemPromptTextarea.value = apiConfig.systemPrompt || '';
      if (headerModelSelect) headerModelSelect.value = apiConfig.model;
    }

    // Settings Modal
    function openSettings() {
      updateApiUI();
      settingsModal.classList.add('active');
      document.body.style.overflow = 'hidden';
    }

    function closeSettings() {
      settingsModal.classList.remove('active');
      document.body.style.overflow = '';
    }

    settingsBtn.addEventListener('click', openSettings);
    settingsClose.addEventListener('click', closeSettings);
    settingsModal.addEventListener('click', (e) => {
      if (e.target === settingsModal) closeSettings();
    });

    customApiToggle.addEventListener('click', () => {
      apiConfig.useCustomKey = !apiConfig.useCustomKey;
      saveApiConfig();
      updateApiUI();
    });

    apiProviderSelect.addEventListener('change', () => {
      apiConfig.provider = apiProviderSelect.value;
      saveApiConfig();
    });

    apiKeyInput.addEventListener('input', () => {
      apiConfig.apiKey = apiKeyInput.value.trim();
      saveApiConfig();
    });

    // Free model selector (always visible)
    modelSelect.addEventListener('change', () => {
      apiConfig.model = modelSelect.value;
      if (headerModelSelect) headerModelSelect.value = modelSelect.value;
      saveApiConfig();
    });
    
    // Header model selector
    if (headerModelSelect) {
      headerModelSelect.addEventListener('change', () => {
        apiConfig.model = headerModelSelect.value;
        modelSelect.value = headerModelSelect.value;
        saveApiConfig();
      });
    }

    // System prompt textarea
    if (systemPromptTextarea) {
      systemPromptTextarea.addEventListener('blur', () => {
        apiConfig.systemPrompt = systemPromptTextarea.value.trim();
        saveApiConfig();
      });
    }

    // Custom model selector (when using own API key)
    if (customModelSelect) {
      customModelSelect.addEventListener('change', () => {
        apiConfig.model = customModelSelect.value;
        saveApiConfig();
      });
    }

    // Export/Import Data
    function exportAllData() {
      const data = {
        version: '2.0',
        exportDate: new Date().toISOString(),
        conversations: conversations,
        apiConfig: { ...apiConfig, apiKey: '' }, // Don't export API key
        theme: localStorage.getItem(THEME_KEY)
      };
      
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `quickgpt-backup-${Date.now()}.json`;
      a.click();
      URL.revokeObjectURL(url);
      showToast('Data exported successfully!', 'success');
    }

    function importData(file) {
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const data = JSON.parse(e.target.result);
          
          if (!data.conversations) {
            showToast('Invalid backup file', 'error');
            return;
          }

          // Smart merge: keep conversations that don't exist in import
          const importedConvos = data.conversations;
          const existingIds = Object.keys(conversations);
          const importedIds = Object.keys(importedConvos);
          
          // Find unique conversations in current data
          const uniqueExisting = existingIds.filter(id => !importedIds.includes(id));
          
          // Merge: imported + unique existing
          const merged = { ...importedConvos };
          uniqueExisting.forEach(id => {
            merged[id] = conversations[id];
          });
          
          conversations = merged;
          saveAllConversations();
          
          // Switch to first imported conversation or create new
          const firstImportedId = importedIds[0];
          if (firstImportedId && conversations[firstImportedId]) {
            switchConversation(firstImportedId);
          } else if (Object.keys(conversations).length === 0) {
            const newId = createConversation();
            switchConversation(newId);
          }
          
          renderConversationList();
          
          const importCount = importedIds.length;
          const keptCount = uniqueExisting.length;
          showToast(`Imported ${importCount} conversations, kept ${keptCount} unique existing ones`, 'success');
          closeSettings();
        } catch (e) {
          console.error('Import error:', e);
          showToast('Failed to import data: ' + e.message, 'error');
        }
      };
      reader.readAsText(file);
    }

    if (exportAllBtn) exportAllBtn.addEventListener('click', exportAllData);
    
    if (importDataBtn) {
      importDataBtn.addEventListener('click', () => {
        importFileInput?.click();
      });
    }
    
    if (importConversationsBtn) {
      importConversationsBtn.addEventListener('click', () => {
        importFileInput?.click();
        exportMenu?.classList.remove('open');
      });
    }
    
    if (importFileInput) {
      importFileInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
          importData(file);
          e.target.value = ''; // Reset input
        }
      });
    }
    
    if (clearAllDataBtn) {
      clearAllDataBtn.addEventListener('click', () => {
      if (!confirm('‚ö†Ô∏è Delete ALL conversations and settings? This cannot be undone.')) return;
      
      localStorage.clear();
      conversations = {};
      apiConfig = { useCustomKey: false, provider: 'openai', apiKey: '', model: 'gpt-3.5-turbo' };
      const newId = createConversation();
      switchConversation(newId);
      showToast('All data cleared', 'success');
      closeSettings();
      location.reload();
    });
  }

    // Token estimation (rough approximation: 1 token ‚âà 4 characters)
    function estimateTokens(text) {
      return Math.ceil(text.length / 4);
    }

    function calculateConversationTokens(messages) {
      let total = 0;
      messages.forEach(msg => {
        total += estimateTokens(msg.content);
      });
      return total;
    }

    function generateId() {
      return 'conv_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }

    function generateTitle(firstMessage) {
      // Generate title from first 40 characters of first user message
      const title = firstMessage.substring(0, 40).trim();
      return title.length < firstMessage.length ? title + '...' : title;
    }

    function formatDate(timestamp) {
      const date = new Date(timestamp);
      const now = new Date();
      const diffMs = now - date;
      const diffMins = Math.floor(diffMs / 60000);
      const diffHours = Math.floor(diffMs / 3600000);
      const diffDays = Math.floor(diffMs / 86400000);

      if (diffMins < 1) return 'Just now';
      if (diffMins < 60) return `${diffMins}m ago`;
      if (diffHours < 24) return `${diffHours}h ago`;
      if (diffDays < 7) return `${diffDays}d ago`;
      return date.toLocaleDateString();
    }

    function createConversation() {
      const id = generateId();
      conversations[id] = {
        id: id,
        title: 'New Chat',
        messages: [],
        created: Date.now(),
        updated: Date.now(),
        tokenCount: 0
      };
      return id;
    }

    function switchConversation(conversationId) {
      if (!conversations[conversationId]) return;
      
      activeConversationId = conversationId;
      localStorage.setItem(ACTIVE_CONVO_KEY, conversationId);
      
      // Clear current chat
      chatBox.innerHTML = '';
      
      // Load conversation messages
      const convo = conversations[conversationId];
      convo.messages.forEach(msg => {
        if (msg.role === 'user') {
          addUserMessage(msg.content, false);
        } else if (msg.role === 'assistant') {
          addAIMessage(msg.content, false);
        }
      });
      
      // On mobile, respect the user's sidebar preference
      // (Don't auto-collapse, let them control it with the burger menu)
      
      // Render placeholder if empty
      if (convo.messages.length === 0) {
        renderPlaceholder();
      }
      
      // Update UI
      renderConversationList();
      scrollToBottom();
    }

    function deleteConversation(conversationId) {
      if (!confirm('Delete this conversation? This cannot be undone.')) return;
      
      delete conversations[conversationId];
      
      // If deleted conversation was active, switch to another or create new
      if (activeConversationId === conversationId) {
        const otherIds = Object.keys(conversations);
        if (otherIds.length > 0) {
          switchConversation(otherIds[0]);
        } else {
          const newId = createConversation();
          switchConversation(newId);
        }
      }
      
      saveAllConversations();
      renderConversationList();
    }

    function saveAllConversations() {
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(conversations));
      } catch (e) {
        console.error('Failed to save conversations:', e);
      }
    }

    function loadAllConversations() {
      try {
        const stored = localStorage.getItem(STORAGE_KEY);
        if (stored) {
          conversations = JSON.parse(stored);
          
          // Load active conversation
          const activeId = localStorage.getItem(ACTIVE_CONVO_KEY);
          if (activeId && conversations[activeId]) {
            activeConversationId = activeId;
          } else if (Object.keys(conversations).length > 0) {
            activeConversationId = Object.keys(conversations)[0];
          }
        }
        
        // Create first conversation if none exist
        if (Object.keys(conversations).length === 0) {
          const id = createConversation();
          activeConversationId = id;
        }
        
        // Switch to active conversation
        if (activeConversationId) {
          switchConversation(activeConversationId);
        }
      } catch (e) {
        console.error('Failed to load conversations:', e);
        // Create new conversation on error
        const id = createConversation();
        activeConversationId = id;
        switchConversation(id);
      }
    }

    function renderConversationList() {
      conversationList.innerHTML = '';
      
      // Sort by updated time (most recent first)
      const sortedIds = Object.keys(conversations).sort((a, b) => {
        return conversations[b].updated - conversations[a].updated;
      });
      
      sortedIds.forEach(id => {
        const convo = conversations[id];
        const item = document.createElement('div');
        item.className = 'conversation-item' + (id === activeConversationId ? ' active' : '');
        item.onclick = (e) => {
          if (!e.target.classList.contains('conversation-delete')) {
            switchConversation(id);
          }
        };
        
        item.innerHTML = `
          <div class="conversation-title">${escapeHtml(convo.title)}</div>
          <div class="conversation-meta">
            <span class="conversation-date">${formatDate(convo.updated)}</span>
            <span class="conversation-tokens" title="Estimated tokens">‚ö°${convo.tokenCount}</span>
            <button class="conversation-delete" onclick="event.stopPropagation(); deleteConversation('${id}')" title="Delete">üóëÔ∏è</button>
          </div>
        `;
        
        conversationList.appendChild(item);
      });
    }

    function updateActiveConversation(userMessage, aiMessage) {
      if (!activeConversationId) return;
      
      const convo = conversations[activeConversationId];
      
      // Update title from first user message (before adding messages)
      if (convo.messages.length === 0 && userMessage) {
        convo.title = generateTitle(userMessage);
      }
      
      // Add messages
      if (userMessage) {
        convo.messages.push({ role: 'user', content: userMessage });
      }
      if (aiMessage) {
        convo.messages.push({ role: 'assistant', content: aiMessage });
      }
      
      // Update token count
      convo.tokenCount = calculateConversationTokens(convo.messages);
      
      // Update timestamp
      convo.updated = Date.now();
      
      // Save
      saveAllConversations();
      renderConversationList();
    }

    function getActiveConversationHistory() {
      if (!activeConversationId || !conversations[activeConversationId]) {
        return [];
      }
      return conversations[activeConversationId].messages;
    }

    function getPlaceholder() {
      return document.getElementById('placeholder-wrap') || document.querySelector('.placeholder-message');
    }

    const inputContainer = document.querySelector('.input-container');

    function setSendLoading(loading) {
      sendButton.disabled = loading;
      sendButton.style.opacity = loading ? 0.6 : 1;
      sendButton.style.display = loading ? 'none' : '';
      stopButton.style.display = loading ? '' : 'none';
      if (inputContainer) inputContainer.classList.toggle('sending', loading);
      document.body.classList.toggle('chat-loading', loading);
      if (loading) {
        sendButton.setAttribute('aria-busy', 'true');
      } else {
        sendButton.innerHTML = 'Send';
        sendButton.removeAttribute('aria-busy');
      }
    }

    function doFetch(userMessage, loadingMessageId) {
      currentAbortController = new AbortController();
      
      // Prepare request body
      const requestBody = {
        message: userMessage,
        history: getActiveConversationHistory(),
        model: apiConfig.model, // Always send model
        systemPrompt: apiConfig.systemPrompt // Always send custom instructions
      };
      
      // Add custom API config if using custom key
      if (apiConfig.useCustomKey && apiConfig.apiKey) {
        requestBody.customApiKey = apiConfig.apiKey;
        requestBody.provider = apiConfig.provider;
      }
      
      fetch('/.netlify/functions/chat', {
        method: 'POST',
        body: JSON.stringify(requestBody),
        headers: { 'Content-Type': 'application/json' },
        signal: currentAbortController.signal
      })
        .then(response => response.json().then(data => ({ ok: response.ok, status: response.status, data })))
        .then(async ({ ok, status, data }) => {
          const errorMsg = data.error || (ok ? null : 'Request failed');
          const aiMessage = ok ? data.message : ('**Error:** ' + (errorMsg || 'Please try again.'));
          await replaceLoadingMessage(loadingMessageId, aiMessage);
          if (ok) {
            updateActiveConversation(userMessage, data.message);
            lastFailedUserMessage = null;
          } else {
            if (status === 429) lastFailedUserMessage = userMessage;
            showToast(errorMsg || 'Something went wrong.', 'error', status === 429 ? userMessage : null);
          }
          setSendLoading(false);
          updateCharCounter();
          scrollToBottom();
        })
        .catch(error => {
          if (error.name === 'AbortError') {
            replaceLoadingMessage(loadingMessageId, '*Generation stopped.*');
          } else {
            console.error('An error occurred:', error);
            replaceLoadingMessage(loadingMessageId, 'Sorry, having trouble connecting. Please check your connection and try again.');
            showToast('Connection error. Please try again.', 'error');
          }
          setSendLoading(false);
          updateCharCounter();
          scrollToBottom();
        });
    }

    function stopRequest() {
      if (currentAbortController) currentAbortController.abort();
    }

    function sendMessageHandler() {
      const placeholderEl = getPlaceholder();
      if (placeholderEl) placeholderEl.style.display = 'none';

      const userMessage = userInput.value.trim();
      if (!userMessage) return;
      if (userMessage.length > MAX_CHARS) {
        showToast('Message is too long. Max ' + MAX_CHARS + ' characters.', 'error');
        return;
      }

      addUserMessage(userMessage, false); // Don't save yet - will save in doFetch after success
      const loadingMessageId = addLoadingMessage();
      userInput.value = '';
      updateCharCounter();
      setSendLoading(true);
      doFetch(userMessage, loadingMessageId);
    }

    function addUserMessage(message, save = true) {
      const messageDiv = document.createElement('div');
      messageDiv.className = 'message user-message';
      messageDiv.innerHTML = `
        <div class="user-message-inner">
          <span class="user-message-text">${escapeHtml(message)}</span>
        </div>
      `;
      chatBox.appendChild(messageDiv);
      if (save) {
        updateActiveConversation(message, null);
      }
      scrollToBottom();
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function addLoadingMessage() {
      const messageId = 'loading-' + Date.now();
      const messageDiv = document.createElement('div');
      messageDiv.id = messageId;
      messageDiv.className = 'message ai-message loading-yet';
      messageDiv.innerHTML = '<span class="typing-dot"></span><span class="typing-dot"></span><span class="typing-dot"></span>';
      chatBox.appendChild(messageDiv);
      scrollToBottom();
      return messageId;
    }

    function deleteMessage(button) {
      const msgEl = button.closest('.message');
      if (!msgEl) return;
      const messages = Array.from(chatBox.querySelectorAll('.message'));
      const idx = messages.indexOf(msgEl);
      if (idx < 0) return;
      const isUser = msgEl.classList.contains('user-message');
      let otherEl = null;
      if (isUser && messages[idx + 1] && messages[idx + 1].classList.contains('ai-message')) {
        otherEl = messages[idx + 1];
      } else if (!isUser && messages[idx - 1] && messages[idx - 1].classList.contains('user-message')) {
        otherEl = messages[idx - 1];
      }
      
      // Remove from conversation
      if (activeConversationId && conversations[activeConversationId]) {
        const convo = conversations[activeConversationId];
        const pairIndex = isUser ? Math.floor(idx / 2) : Math.floor((idx - 1) / 2);
        convo.messages.splice(pairIndex * 2, 2);
        saveAllConversations();
      }
      
      // Remove from DOM
      msgEl.remove();
      if (otherEl) otherEl.remove();
      
      // Check if empty
      const hasMessages = activeConversationId && conversations[activeConversationId] && conversations[activeConversationId].messages.length > 0;
      if (!hasMessages) renderPlaceholder();
      updateScrollToBottomVisibility();
    }
    
    // Make deleteMessage globally accessible
    window.deleteMessage = deleteMessage;

     const ICON_TEMPLATES = {
       clock: '<i class="fa-regular fa-clock" aria-hidden="true"></i>',
       regenerate: '<i class="fa-solid fa-arrow-rotate-right" aria-hidden="true"></i>',
       copy: '<i class="fa-solid fa-clone" aria-hidden="true"></i>'
     };

    function createAiMessageFooter(timestamp, showRegenerate = true) {
      const footer = document.createElement('div');
      footer.className = 'ai-message-footer';

      const timeSpan = document.createElement('span');
      timeSpan.className = 'ai-message-time';
      timeSpan.innerHTML = `${ICON_TEMPLATES.clock}<span>${timestamp}</span>`;

      const actions = document.createElement('span');
      actions.className = 'ai-message-actions';

      if (showRegenerate) {
        const regenBtn = document.createElement('button');
        regenBtn.type = 'button';
        regenBtn.className = 'icon-btn regenerate-btn';
        regenBtn.setAttribute('aria-label', 'Regenerate response');
        regenBtn.innerHTML = ICON_TEMPLATES.regenerate;
        regenBtn.addEventListener('click', () => regenerateResponse(regenBtn));
        actions.appendChild(regenBtn);
      }

      const copyBtn = document.createElement('button');
      copyBtn.type = 'button';
      copyBtn.className = 'icon-btn copy-btn';
      copyBtn.setAttribute('aria-label', 'Copy response');
      copyBtn.innerHTML = ICON_TEMPLATES.copy;
      copyBtn.addEventListener('click', () => copyMessage(copyBtn));

      actions.appendChild(copyBtn);

      footer.appendChild(timeSpan);
      footer.appendChild(actions);
      return footer;
    }

    function installCodeCopyButtons(container = document) {
      container.querySelectorAll('pre').forEach(pre => {
        if (pre.dataset.hasCopyBtn) return;
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'code-copy-btn';
        btn.setAttribute('aria-label', 'Copy code block');
        btn.innerHTML = '<i class="fa-solid fa-copy"></i>';
        btn.addEventListener('click', () => {
          const text = pre.innerText || pre.textContent;
          navigator.clipboard.writeText(text).then(() => {
            showToast('Code copied to clipboard!');
          }).catch(() => {
            showToast('Unable to copy code', 'error');
          });
        });
        pre.appendChild(btn);
        pre.dataset.hasCopyBtn = 'true';
      });
    }

    async function addAIMessage(content, save = true) {
      const messageDiv = document.createElement('div');
      messageDiv.className = 'message ai-message';
      
      const aiMessageContent = document.createElement('div');
      aiMessageContent.className = 'ai-message-content';
      const timestamp = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      const contentDiv = document.createElement('div');
      await loadMarked();
      contentDiv.innerHTML = marked.parse(content);
      aiMessageContent.appendChild(contentDiv);
      aiMessageContent.appendChild(createAiMessageFooter(timestamp, true));
      messageDiv.appendChild(aiMessageContent);
      chatBox.appendChild(messageDiv);

      if (typeof Prism !== 'undefined') {
        installCodeCopyButtons(contentDiv);
        contentDiv.querySelectorAll('pre code').forEach(el => Prism.highlightElement(el));
      }
      scrollToBottom();
    }

    async function replaceLoadingMessage(messageId, content, showRegenerate = true) {
      const loadingElement = document.getElementById(messageId);
      if (!loadingElement) return;
      loadingElement.classList.remove('loading-yet');
      loadingElement.classList.add('ai-message');

      const aiMessageContent = document.createElement('div');
      aiMessageContent.className = 'ai-message-content';
      const timestamp = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      const contentDiv = document.createElement('div');
      await loadMarked();
      contentDiv.innerHTML = marked.parse(content);
      aiMessageContent.appendChild(contentDiv);
      aiMessageContent.appendChild(createAiMessageFooter(timestamp, showRegenerate));
      loadingElement.appendChild(aiMessageContent);

      if (typeof Prism !== 'undefined') {
        contentDiv.querySelectorAll('pre code').forEach(el => Prism.highlightElement(el));
      }
      scrollToBottom();
    }
    function regenerateResponse(button) {
      const aiMsgEl = button.closest('.ai-message');
      if (!aiMsgEl) return;
      
      // Get all messages in the chat
      const messages = Array.from(chatBox.querySelectorAll('.message'));
      const idx = messages.indexOf(aiMsgEl);
      if (idx < 1) return;
      
      // Get the user message before this AI message
      const userMsgEl = messages[idx - 1];
      const textEl = userMsgEl.querySelector('.user-message-text');
      const userContent = (textEl ? textEl.textContent : userMsgEl.textContent).trim();
      
      // Remove the messages from the conversation
      if (activeConversationId && conversations[activeConversationId]) {
        const convo = conversations[activeConversationId];
        const pairIndex = Math.floor((idx - 1) / 2);
        convo.messages.splice(pairIndex * 2, 2);
        saveAllConversations();
      }
      
      // Remove from DOM
      userMsgEl.remove();
      aiMsgEl.remove();
      
      // Check if conversation is empty
      const hasMessages = activeConversationId && conversations[activeConversationId] && conversations[activeConversationId].messages.length > 0;
      if (!hasMessages) renderPlaceholder();
      
      // Regenerate the response
      addUserMessage(userContent, false);
      const loadingMessageId = addLoadingMessage();
      setSendLoading(true);
      doFetch(userContent, loadingMessageId);
    }
    
    // Make functions globally accessible for onclick handlers
    window.regenerateResponse = regenerateResponse;

    function copyMessage(button) {
      const messageContent = button.closest('.ai-message').querySelector('.ai-message-content > div:last-child');
      const textToCopy = messageContent ? (messageContent.textContent || messageContent.innerText) : '';
      copyToClipboard(textToCopy, button, 'üìã Copy');
    }
    
    window.copyMessage = copyMessage;
    
    function copyToClipboard(text, button, resetLabel) {
      navigator.clipboard.writeText(text).then(() => {
        showToast('Message copied to clipboard!');
      button.innerHTML = '<i class="fa-solid fa-check"></i>';
      button.style.background = 'var(--success-color)';
      setTimeout(() => { button.innerHTML = resetLabel; button.style.background = ''; }, 2000);
      }).catch(() => showToast('Failed to copy message', 'error'));
    }

    function showToast(message, type = 'success', opts = {}) {
      const options = (typeof opts === 'string' || opts === null)
        ? { retryMessage: opts }
        : (opts || {});
      const { retryMessage = null, actionLabel, actionHandler, duration } = options;
      const hasActions = Boolean(retryMessage || (actionLabel && actionHandler));
      const toast = document.createElement('div');
      toast.className = 'toast toast-' + type + (hasActions ? ' toast-with-action' : '');
      toast.setAttribute('role', 'status');
      toast.appendChild(document.createTextNode(message));

      if (retryMessage) {
        const retryBtn = document.createElement('button');
        retryBtn.type = 'button';
        retryBtn.className = 'toast-retry';
        retryBtn.textContent = 'Retry';
        retryBtn.addEventListener('click', () => {
          toast.remove();
          if (lastFailedUserMessage) {
            addUserMessage(lastFailedUserMessage, false);
            const loadingMessageId = addLoadingMessage();
            setSendLoading(true);
            doFetch(lastFailedUserMessage, loadingMessageId);
          }
        });
        toast.appendChild(retryBtn);
      }

      if (actionLabel && typeof actionHandler === 'function') {
        const actionBtn = document.createElement('button');
        actionBtn.type = 'button';
        actionBtn.className = 'toast-action';
        actionBtn.textContent = actionLabel;
        actionBtn.addEventListener('click', () => {
          toast.remove();
          actionHandler();
        });
        toast.appendChild(actionBtn);
      }

      document.body.appendChild(toast);
      const autoRemoveDelay = duration ?? (hasActions ? 8000 : 3000);
      setTimeout(() => toast.remove(), autoRemoveDelay);
    }

    function showInstallPromptToast() {
      if (!deferredPrompt) return;
      showToast('Install QuickGPT for quick access', 'info', {
        actionLabel: 'Install',
        actionHandler: async () => {
          try {
            const promptEvent = deferredPrompt;
            deferredPrompt = null;
            promptEvent.prompt();
            const choiceResult = await promptEvent.userChoice;
            showToast(
              choiceResult.outcome === 'accepted'
                ? 'Thanks for installing QuickGPT!'
                : 'Install dismissed',
              choiceResult.outcome === 'accepted' ? 'success' : 'error'
            );
          } catch (error) {
            console.error('Install prompt error:', error);
            showToast('Unable to open install prompt', 'error');
          }
        },
        duration: 5000
      });
    }

    window.addEventListener('beforeinstallprompt', (event) => {
      event.preventDefault();
      deferredPrompt = event;
      showInstallPromptToast();
    });

    window.addEventListener('appinstalled', () => {
      deferredPrompt = null;
      showToast('QuickGPT installed! Launch from your home screen anytime.', 'success');
    });

    if ('serviceWorker' in navigator) {
      navigator.serviceWorker
        .register('/sw.js')
        .then(() => {
          console.log('Service worker registered.');
        })
        .catch((error) => {
          console.warn('Service worker registration failed:', error);
        });
    }

    function showVersionToast() {
      if (versionToastShown) return;
      versionToastShown = true;
      showToast(`QuickGPT ${APP_VERSION} (${APP_PATCH})`, 'info', { duration: 4000 });
    }

    function downloadExport(blob, filename) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.click();
      URL.revokeObjectURL(url);
    }

    function exportChat(format) {
      const messages = getActiveConversationHistory();
      if (!messages || messages.length === 0) {
        showToast('No messages to export', 'error');
        return;
      }
      const dateStr = new Date().toISOString().split('T')[0];
      const exportData = {
        timestamp: new Date().toISOString(),
        messages: messages,
        totalMessages: messages.length
      };
      const jsonData = JSON.stringify(exportData, null, 2);
      const textData = messages.map(m => (m.role === 'user' ? 'You' : 'AI') + ': ' + m.content).join('\n\n');
      const mdData = messages.map(m => (m.role === 'user' ? '**You:**' : '**AI:**') + '\n\n' + m.content).join('\n\n---\n\n');

      if (format === 'json' || format === 'all') downloadExport(new Blob([jsonData], { type: 'application/json' }), 'quickgpt-chat-' + dateStr + '.json');
      if (format === 'txt' || format === 'all') downloadExport(new Blob([textData], { type: 'text/plain' }), 'quickgpt-chat-' + dateStr + '.txt');
      if (format === 'md' || format === 'all') downloadExport(new Blob([mdData], { type: 'text/markdown' }), 'quickgpt-chat-' + dateStr + '.md');
      showToast(format === 'all' ? 'Chat exported (JSON, TXT, Markdown)!' : 'Exported as ' + format.toUpperCase() + '!');
    }

    function updateCharCounter() {
      const length = userInput.value.length;
      charCounter.textContent = length + ' / ' + MAX_CHARS;
      charCounter.classList.toggle('warning', length > MAX_CHARS * 0.8);
      charCounter.classList.toggle('danger', length > MAX_CHARS * 0.95);
      sendButton.disabled = sendButton.getAttribute('aria-busy') === 'true' || length > MAX_CHARS;
    }

    function renderPlaceholder() {
      const wrap = document.createElement('div');
      wrap.className = 'placeholder-message';
      wrap.id = 'placeholder-wrap';
      wrap.innerHTML = '<span>Start a conversation by typing a message...</span>' +
        '<div class="suggested-prompts" id="suggested-prompts">' +
        '<button type="button" class="suggested-prompt" data-prompt="Explain quantum computing in simple terms">Explain quantum computing</button>' +
        '<button type="button" class="suggested-prompt" data-prompt="Write a short haiku about coding">Write a haiku</button>' +
        '<button type="button" class="suggested-prompt" data-prompt="Help me debug: my function returns undefined">Debug this code</button>' +
        '<button type="button" class="suggested-prompt" data-prompt="Summarize the key points of a long article">Summarize an article</button>' +
        '</div>';
      chatBox.appendChild(wrap);
      wrap.querySelectorAll('.suggested-prompt').forEach(btn => {
        btn.addEventListener('click', () => {
          userInput.value = btn.dataset.prompt || '';
          userInput.focus();
          updateCharCounter();
          sendMessageHandler();
        });
      });
    }

    function clearChat() {
      // Create a new conversation
      const newId = createConversation();
      switchConversation(newId);
      saveAllConversations();
      userInput.value = '';
      userInput.focus();
      updateCharCounter();
    }

    function scrollToBottom() {
      const wrapper = document.getElementById('chat-wrapper');
      if (wrapper) wrapper.scrollTo({ top: wrapper.scrollHeight, behavior: 'smooth' });
      updateScrollToBottomVisibility();
    }

    function updateScrollToBottomVisibility() {
      const wrapper = document.getElementById('chat-wrapper');
      if (!wrapper || !scrollToBottomBtn) return;
      const threshold = 100;
      const nearBottom = wrapper.scrollHeight - wrapper.scrollTop - wrapper.clientHeight < threshold;
      const hasMessages = activeConversationId && conversations[activeConversationId] && conversations[activeConversationId].messages.length > 0;
      scrollToBottomBtn.classList.toggle('visible', !nearBottom && hasMessages);
    }

    // Legacy functions removed - using conversation management now

    function applyTheme(theme) {
      const t = theme || 'dark';
      if (t === 'light') document.documentElement.setAttribute('data-theme', 'light');
      else document.documentElement.removeAttribute('data-theme');
      const metaTheme = document.getElementById('meta-theme-color');
      if (metaTheme) metaTheme.setAttribute('content', t === 'light' ? '#f5f5f5' : '#0f0f0f');
      try { localStorage.setItem(THEME_KEY, t); } catch (e) {}
      if (themeToggle) {
        themeToggle.innerHTML = (t === 'light') ? '<i class="fa-solid fa-sun"></i>' : '<i class="fa-solid fa-moon"></i>';
        themeToggle.setAttribute('aria-label', (t === 'light') ? 'Switch to dark mode' : 'Switch to light mode');
      }

      // Default back to OpenAI free model when not using custom key
      if (!apiConfig.useCustomKey) {
        apiConfig.provider = 'openai';
        apiConfig.model = 'gpt-3.5-turbo';
        if (headerModelSelect) headerModelSelect.value = apiConfig.model;
        if (modelSelect) modelSelect.value = apiConfig.model;
        saveApiConfig();
      }
    }

    function toggleTheme() {
      const current = document.documentElement.getAttribute('data-theme');
      applyTheme(current === 'light' ? 'dark' : 'light');
    }

    sendButton.addEventListener('click', sendMessageHandler);
    stopButton.addEventListener('click', stopRequest);
    if (clearChatBtn) clearChatBtn.addEventListener('click', clearChat);
    if (themeToggle) themeToggle.addEventListener('click', toggleTheme);

    if (exportChatBtn && exportMenu) {
      exportChatBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        exportMenu.classList.toggle('visible');
        exportChatBtn.setAttribute('aria-expanded', exportMenu.classList.contains('visible') ? 'true' : 'false');
      });
      exportMenu.addEventListener('click', (e) => e.stopPropagation());
      exportMenu.querySelectorAll('[data-format]').forEach(btn => {
        btn.addEventListener('click', () => {
          exportChat(btn.dataset.format);
          exportMenu.classList.remove('visible');
          exportChatBtn.setAttribute('aria-expanded', 'false');
        });
      });
    }
    document.addEventListener('click', () => {
      exportMenu?.classList.remove('visible');
      exportChatBtn?.setAttribute('aria-expanded', 'false');
    });

    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        exportMenu?.classList.remove('visible');
        exportChatBtn?.setAttribute('aria-expanded', 'false');
      }
    });

    chatWrapper.addEventListener('scroll', updateScrollToBottomVisibility);
    scrollToBottomBtn.addEventListener('click', () => { scrollToBottom(); scrollToBottomBtn.classList.remove('visible'); });

    userInput.addEventListener('keydown', function (e) {
      if (e.key === 'Enter' && !e.shiftKey) {
        const sendViaKeyboard = (e.ctrlKey || e.metaKey) || !isMobileDevice;
        if (sendViaKeyboard) {
          e.preventDefault();
          if (sendButton.getAttribute('aria-busy') !== 'true' && userInput.value.length <= MAX_CHARS) {
            sendMessageHandler();
          }
        }
      }
      if (e.key === 'Escape') {
        userInput.value = '';
        updateCharCounter();
        userInput.blur();
      }
    });
    userInput.addEventListener('input', function () {
      updateCharCounter();
      this.style.height = 'auto';
      this.style.height = Math.min(this.scrollHeight, 200) + 'px';
    });

    userInput.addEventListener('paste', (e) => {
      const text = (e.clipboardData || window.clipboardData).getData('text/plain');
      if (!text) return;
      e.preventDefault();
      const start = userInput.selectionStart;
      const end = userInput.selectionEnd;
      const val = userInput.value;
      const newVal = val.slice(0, start) + text + val.slice(end);
      if (newVal.length <= MAX_CHARS) {
        userInput.value = newVal;
        userInput.selectionStart = userInput.selectionEnd = start + text.length;
      } else {
        userInput.value = newVal.slice(0, MAX_CHARS);
        userInput.selectionStart = userInput.selectionEnd = Math.min(start + text.length, MAX_CHARS);
      }
      updateCharCounter();
      userInput.style.height = 'auto';
      userInput.style.height = Math.min(userInput.scrollHeight, 200) + 'px';
    });

    document.addEventListener('keydown', function (e) {
      if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
        e.preventDefault();
        clearChat();
      }
    });

    document.getElementById('suggested-prompts').addEventListener('click', function (e) {
      const btn = e.target.closest('.suggested-prompt');
      if (!btn) return;
      userInput.value = btn.dataset.prompt || '';
      userInput.focus();
      updateCharCounter();
      sendMessageHandler();
    });

    // Sidebar toggle
    function toggleSidebar() {
      sidebar.classList.toggle('collapsed');
      sidebarBackdrop.classList.toggle('active');
      const isCollapsed = sidebar.classList.contains('collapsed');
      try {
        localStorage.setItem(SIDEBAR_STATE_KEY, isCollapsed ? 'true' : 'false');
      } catch (e) {
        console.error('Failed to save sidebar state:', e);
      }
    }
    
    // Close sidebar when clicking backdrop
    sidebarBackdrop.addEventListener('click', () => {
      if (!sidebar.classList.contains('collapsed')) {
        toggleSidebar();
      }
    });
    
    sidebarToggle.addEventListener('click', toggleSidebar);
    sidebarToggleMobile.addEventListener('click', toggleSidebar);
    
    // New conversation button
    newConversationBtn.addEventListener('click', clearChat);

    // Initialize
    loadApiConfig();
    
    // Restore sidebar state - default to collapsed on all screens
    try {
      const savedState = localStorage.getItem(SIDEBAR_STATE_KEY);
      if (savedState === 'true' || savedState === null) {
        // User previously collapsed it or first visit - start collapsed
        sidebar.classList.add('collapsed');
        sidebarBackdrop.classList.remove('active');
      } else if (savedState === 'false') {
        // User previously expanded it, keep it expanded
        sidebar.classList.remove('collapsed');
        sidebarBackdrop.classList.add('active');
      }
    } catch (e) {
      // Fallback: start collapsed
      sidebar.classList.add('collapsed');
      sidebarBackdrop.classList.remove('active');
    }
    
    userInput.focus();
    updateCharCounter();
    applyTheme(localStorage.getItem(THEME_KEY) || 'dark');
    loadAllConversations();
    updateScrollToBottomVisibility();
    showVersionToast();
  </script>
  <script src="prism.js"></script>
</body>

</html>